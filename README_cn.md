[English](README.md) | 中文


基于上下文工程的 Claude Code Commands 与 Subagents 协作的多层级文档体系，用以让AI编程工具能够按照用户需求精准开发复杂项目，且开发过程可控，可溯源。

[![License: MIT](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)
[![Version](https://img.shields.io/badge/version-2.0-green.svg)](CHANGELOG.md)

---

## 🚀 快速开始

- 克隆仓库

```bash
git clone https://github.com/baronedog1/ce-mlds-aic.git
cd ce-mlds-aic
```

- 在 Claude Code 中加载 Commands/Agents
  - 将本仓库的 `.claude` 目录放到 Claude Code 的用户根（全局）或你的项目根（局部），即可自动加载 Commands 与 Subagents。（若用中文版本需要去掉后缀）
  - 可通过 Provider 接入 Kimi K2、ChatGLM 4.5 等模型；按对应 Provider 文档配置 API Key，在命令面板选择提供者后运行下列命令。

- 自然语言命令（推荐顺序）

```text
/initial 在根目录初始化：为电商类复杂项目创建根层文档骨架与日志，包含 docs/、database/docs、backend、frontend/shell 等目录，不覆盖现有文件。（将被识别为：scope_dir=root, modules=[backend, frontend-shell], create_examples=true）

/spec-init 在根层完善规范：补充产品概览（目标/用例）、统一 API 规范、数据库索引、代码与测试硬规则，并生成项目计划。（将被识别为：scope_dir=root, seed_requirements="<一句话项目概述；主要模块；关键里程碑>")

# 后端（可选）
cd backend
/initial 在后端模块初始化。（→ scope_dir=backend）
/spec-init 在后端完善规范：补充模块 API 与数据使用说明、任务与测试。（→ scope_dir=backend）

# 前端壳（可选）
cd ../frontend/shell
/initial 在前端壳初始化，并关联后端文档。（→ scope_dir=frontend-shell, backend_ref_dir=../../backend/docs）
/spec-init 在前端壳完善规范：补充页面/集成/数据映射与计划。（→ scope_dir=frontend-shell, backend_ref_dir=../../backend/docs）

# 新增子模块（可选）
mkdir -p ../../backend/modules/orders && cd ../../backend/modules/orders
/initial 在后端子模块初始化。（→ scope_dir=backend-module）
/spec-init 在模块完善规范：补充该模块的 API/数据/测试与计划。（→ scope_dir=backend-module）

# 质量闸（回到根目录）
cd ../../../
/commit-check 统一质量检查，生成报告并链接到日志。
```

- 规则要点
  - 文档统一“三段式”：规则 / 说明 / 实施记录；不贴长代码，仅放路径或链接。
  - 实施阶段只回填“实施记录”，不改动“规则/说明”。
  - 详细流程见 `examples/ecommerce-walkthrough.md`。

---

## 🎯 范围与适用

- 适用：中大型、带前后端/多模块/多环境的复杂项目；需要多人协作、可追溯交付与质量度量。
- 也适用：逐步引入规范的存量项目（无需一次性重构）。
- 不适用：一次性脚本、简单 Demo、纯提示词工程。
- 不替代：单元/集成测试、代码审查、性能/安全测试与基础设施。

---

## 🧠 设计思路

复杂项目中的 AI 编程，真正需要解决的并不是“如何生成更多代码”，而是“如何让增量最小、定位精确、过程可溯源、演进可维护”。所谓“一句话出活”的奇观，在真实工程情境里往往失灵，因为复杂项目并非前端一隅，而是前端、后端、数据库与多子模块的协同；真正的难点在于跨层间契约的一致性与演进的秩序。

大模型之所以常把项目带向“屎山”，并非出于恶意，而是能力边界所致：上下文窗口有限，面对动辄十几个文件、上千行的改动面，只能依赖“上下文压缩”去“看得全”。压缩一旦发生，参数校验、边界条件、幂等等关键事实就会被挤成“摘要的摘要”。当模型无法精确定位“该改哪一行”时，最稳妥的策略就会变成“重写一套”。多轮对话之后，同一能力出现多种写法与多套文件，系统复杂度上升，事实愈发难以对齐，进而陷入自我强化的循环：上下文越不完整，新增越多；新增越多，系统越复杂；系统越复杂，上下文越不可得。

业界已有两类常见改良路径：其一是让压缩更“聪明”，努力在有限窗口里保住“关键事实”；其二是采用“spec‑first”，以自然语言先把要做的事准确定义为规范，再按规范实施并回填文档。这两条路确能在一定规模上降低遗忘与漂移。然而，当项目跨越前后端、数据库与多模块，单一 spec 要么粒度过粗以致细节丢失，要么粒度过细导致文档膨胀至数千行，锚点漂移、记录错位，最终 spec 本身也会沦为“文档屎山”。

因此，我将“一个文档”升级为“一个文档体系”：把上下文当作“图书馆”来治理，而不是一本越写越厚的大书。纵向上，根、子系统与模块各自拥有独立的计划与文档，父子互链但不越权；根层只存放全局规范、里程碑与目录式链接，具体实现下沉到对应层级。横向上，围绕 Architecture、Product、API、Database、Code、Test、Plan 七个维度，采用统一的“三段式”表达（规则、说明、实施记录），并以“唯一信息源”原则约束事实只在唯一位置维护，其它位置仅以链接引用。这样，模型检索到的是“恰当范围内的唯一事实”，而不是模糊且相互矛盾的摘要。

在这套方法中，Claude Code 扮演唯一的“程序员”；与之配合的七个 Subagents 并不直接写代码，而是作为审核者与把关者：它们依据各自领域的文档生成或校对“规则与说明”，并在实施后检视一致性。Subagents 运行于相对独立的上下文之中，不会被实现阶段的偶然细节干扰，这使它们能持续地维护契约与边界（例如错误码或数据契约的一致性），把“偏差”及时拉回正轨。

Commands 则把这一整套工作法固化为可复用的执行宏：先在根与模块层通过 `/initial` 建立骨架与锚点，再用 `/spec‑init` 把“规则与说明”讲清楚。实施阶段通过 `/execute‑plan` 只回填“实施记录”，而非改动“规则/说明”；当出现问题，用 `/fix‑issue` 以“问题→原因→改动→验证”的闭环结构进行修复与回填；在关键节点以 `/commit‑check` 串联各 Subagents 做统一质量闸。随着每次动作把实施记录与日志串成时间轴，证据链能够被持续沉淀，变更得以被解释、被追述、被复现。

这便是“上下文工程 × 文档体系 × Commands × Subagents”的核心：用分层与分面把复杂度“钉住”，用唯一事实与可追溯的时间轴把过程“记住”。当模型不再需要每次遍历全量代码，而是沿着“当前任务与关联锚点”精准落到某几个文件时，“写更多”自然让位于“写对、写准、写得可维护”。

---

## 📚 文档体系（每类文档由一个Agent维护）

- Architecture 文档：定义系统/模块边界、依赖准入、目录骨架、命名约束与禁用模式；“实施记录”只登记架构决策与证据链接。
- Product 文档：阐明目标用户/用例、页面/流程/状态机与命名；“实施记录”登记本轮交付的页面或流程及其实现路径。
- API 文档：约定风格/版本/鉴权/幂等/错误码/分页等；“实施记录”为端点清单（一句话说明 + 实现文件路径）。
- Database 文档：命名/约束/迁移策略与核心实体关系；“实施记录”登记迁移清单、受影响实体与脚本路径。
- Code 文档：硬性规范（命名/错误/日志/依赖准入/边界控制/安全红线/禁止模式）；“实施记录”只在必要时补充重构与修复摘要。
- Test 文档：测试策略、覆盖地图与环境矩阵；“实施记录”登记通过/失败/阻塞摘要与报告链接。
- Plan 文档：权威任务台账（状态/负责人/截止/锚点/日志链路）；不重复维护细节，细节落在对应分面文档与实现路径。

统一写法：所有文档均采用“规则 / 说明 / 实施记录”，事实只在唯一位置维护，其它位置以链接引用。

---

## 🤖 Subagents 职责

- Architect Agent：把关边界/依赖/目录骨架与命名约束；生成或校对 Architecture 文档，输出结构一致性建议。
- Product Manager Agent：组织需求与用例，生成页面/流程/状态机说明；维护 Product 文档与计划锚点。
- API Expert Agent：维护 API 基本原则与端点实施记录；校对契约与错误码，输出缺失/不一致清单。
- Database Expert Agent：维护数据库索引与迁移策略；审核模块使用的表与变更记录，强调“唯一数据入口”。
- Code Agent：维护代码层硬规则与禁用模式；输出依赖准入与边界控制建议，识别重复实现。
- Test Agent：维护测试策略与覆盖地图；关联合同/用例锚点，输出阻塞/验收门槛。
- Task Planner Agent：组织 Plan 文档台账；维系任务锚点与双向互链，保障“实施记录”回填闭环。

Subagents 不直接写功能代码，而是作为审核与把关角色，保障规范一致性与可追溯性。

---

## 🛠️ Commands 用法

- /initial：初始化骨架与文档空头，创建日志与锚点；根层可预建 backend / frontend-shell 目录与 database 索引。
- /spec-init：完善“规则与说明”，建立互链与任务锚点；不写实现代码。
- /execute-plan：按任务实施，仅回填“实施记录”（Product/API/Database/Test/Plan 等），不修改“规则/说明”。
- /fix-issue：以“问题→原因→改动→验证”闭环修复，回填到相应分面文档的“实施记录”，并产生日志。
- /commit-check：串联各 Subagents 做统一质量闸，输出报告并链接日志；不直接改文档。
- /reset（可选）：建立回溯点与回滚范围；如涉及架构回退，同步“说明”。

---

## 🔎 案例速览（简述）

问题：创建订单接口返回 500。

处置：执行 `/fix-issue`，将问题挂到“创建订单”任务锚点 → 顺着 API 文档锚点直达实现文件 → 对齐错误码与数据契约，做最小改动 → 本地验证通过 → 在 API/Database/Test/Plan 的“实施记录”回填摘要与证据 → 运行 `/commit-check` 通过后合入。

更多完整演练与自然语言命令示例，见 `examples/ecommerce-walkthrough.md` 与 `examples/README.md`。

---

## 🤝 结语与联系

本项目将持续演进与更新，欢迎 Star、Issue 与 PR 交流改进思路与最佳实践。

- 小红书：四呆院夜一
- Email：wuyy49@gmail.com

很多复杂工作流都可以通过定义 Agent 与 Command 来实现，不止于工程：例如“长篇小说创作流程”“多资料汇编成册”“结构化知识库编纂”等。我会在后续持续发布更多 Commands × Agents 协同的项目与范式，欢迎一起探索与共建。

---

## 🤝 许可
- 许可协议：MIT（见 `LICENSE`）

